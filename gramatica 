<PROGRAMA>
S -> ( program id S' S'' MAIN )
S' -> DECLARACIONVARIABLLES | epsilon
S'' -> DECLARACIONFUNCIONES | epsilon

<DECLARACIONVARIABLLES>
S -> ( vars S' )
S' -> DECLARE S' | epsilon

<DECLARACIONFUNCIONES>
S -> ( functions S' )
S' -> FUNCION S' | epsilon

<MAIN>
S -> ( main S' )
S' -> BLOQUE S' | epsilon

<IMPRIMIR> 
S -> ( print S' )
S' -> cte_ctar | EXPRESION | LISTFUNCITONS | LAMBDA 

<DECLARE>
S -> ( declare id S' )
S' -> DEFINIRLISTA | DEFINIRCTE

<DEFINIRLISTA>
S -> '( )
S' -> DEFINIRCTE S' | epsilon

<DEFINIRCTE>
S -> cte_int | cte_float | cte_char 

<LISTA> 
S -> id | '( S' )  //aqui se deberia de agregar el poder poner una lista sin declarar 
S' -> cte_int S' | cte_float S' | cte_char | epsilon

<VARCTE>
S -> id // id2
S -> cte_int // 1
S -> cte_float // 1.1

<LISTFUNCITONS>
S -> RETURNELEMENT | RETURNLIST

<RETURNLIST>
S -> ( S' LISTA ) | APPEND | LISTA | CREATELIST | MAP | LLAMADA | FILTER
S' -> cdr


<RETURNLIST>
S -> ( cdr LISTA ) | APPEND | LISTA | CREATELIST | MAP | LLAMADA | FILTER

<RETURNELEMENT>
S -> ( S' RETURNLIST ) | #t | #f
S' -> car | length | null? | list? | empty? | tail <--- agregue este ultimo por que dijo elda en la llamada que esperaba como list functions

<APPEND>
S -> ( append RETURNLIST RETURNLIST S' )
S' -> RETURNLIST S' | epsilon

<CREATELIST> //funcion list
S -> ( list s' )
S' -> EXPRESION S' | epsilon

<MAP>
S -> ( map S'' RETURNLIST S' )
S'' -> ( lambda (PARAM) BLOQUE )

// NEW ONE
<MAP>
S -> ( map (lambda (RETURNLIST S') (PARAM) EXP )  )
S' -> RETURNLIST S' | epsilon

<MAP> 
S -> (map (lambda (RETURNLIST S') (PARAMMAP) EXPRESION ) )
S' -> RETURNLIST | epsilon

<PARAMMAP>
S -> ID S'
S' -> ID | epsilon


<MAP> 
S -> (map (lambda (RETURNLIST) (PARAMMAP) EXPRESION ) )

S' -> RETURNLIST | epsilon
S'' -> PARAMMAP | epsilon

l -> '(1 2 3)
'(2 3 4)
(map (lambda (l) (x) (+ x 1) ))

l -> (2 3)
l1 -> ( 3 2)
(map (lambda (l l1) (x y) (> x y) ))
(map (lambda (l) (x) (> x 1) ))
-> '(0 1)

-- las dos listas deben de tener el mismo len
-- lo de EXP tiene que quedar un int o float
-- map acepta una o dos listas


l2 -> '(1 2 3)
(map (lambda (l l2) ( x y) ( + x y)  ))
-> '(2 4 6)

<FILTER>
S -> ( filter S' RETURNLIST )
S' -> ( lambda (PARAM) S'' ) | even? | int? | float?
S'' -> EXPRESION

S -> (filter S' )
S' -> even? RETURNLIST | int? RETURNLIST | float? RETURNLIST
S' -> (lambda (RETURNLIST) (PARAM) EXPRESION  ) 



filter null l1 l5
getnext l1 null temp 
... cagadero de expresion > tenemos que checar que el resultado sea booleano
> l1 5 temp
NDMV bool temp(82) l5 
GOTO NULL NULL inicio filter 
finishfilter null null null 

(filter (lambda ( l ) (x) (> l 5) )  )

[ LENGTH , l , NULL , 4009 ]
61 : [ = , 4011 , NULL , 13007 ]
62 : [ < , 4011 , 4009 , 7000 ]
63 : [ GOTOF , 7000 , NULL , 70 ]
64 : [ INDEX , l , 4011 , 4010 ]
65 : [ > , addressx , address5 , addressbool ]

66 : [ NDMV , 7000 , 4010 , listAux14 ]
67 : [ + , 4011 , 13008 , 4012 ]
68 : [ = , 4012 , NULL , 4011 ]
69 : [ GOTO , NULL , NULL , 62 ]

-- que necesito funcion en dmm de index


S'' -> ( if EXPRESION tt ff )

(filter (lambda  (x) (> x 1) ) l1 )
(> x 1)

( filter even? '(1 2) ) =  2
// size puede ser entre len de lista y 0
// typo igual que el de la lista
// base = la siguiente address que se pueda

// simular un proceso de memoria dinamica



------------------------------------------------------------
Son equivalentes
<EXP> 
S -> ( + EXP EXP ) 
S -> ( - EXP EXP )
S -> ( * EXP EXP ) 
S -> ( / EXP EXP ) 
S -> ( + VARCTE ) 
S -> ( - VARCTE ) 
S -> VARCTE
S -> LLAMADA 
S -> RETURNELEMENT


<EXP> 
S -> ( SIGNOS1 EXP EXP ) 
S -> ( SIGNOS2 EXP EXP )
S -> ( SIGNOS1 VARCTE ) 
S -> VARCTE
S -> LLAMADA 
S -> RETURNELEMENT

<SIGNOS1>
S -> + | -

<SIGNOS2>
S -> * | /

------------------------------------------------------------

<EXPRESION>  // para comparativas
S -> EXP 
S -> ( SIGNOSRELACIONALES EXP EXP )
S -> EXPRESIONESUNARIAS

<SIGNOSRELACIONALES>
S -> > | < | != | =

<EXPRESIONESUNARIAS>
S -> ( S' EXP) | #t | #f
S' -> even? | int? | float? | list? | null? | empty?

<CONDICION>
S -> ( if EXPRESION BLOQUE BLOQUE )

<BLOQUE> 
S -> CONDICION | IMPRIMIR | EXPRESION | LLAMADA | LAMBDA | LISTFUNCITONS | IMPRIMIRLISTA

<TIPO> 
S -> int 
S -> float 
S -> char
S -> void
S -> list

<TIPOVARS> 
S -> int 
S -> float 
S -> char
S -> list

<PARAM>
S -> id S | epsilon


<TYPEPARAM>
S -> TIPOVARS id S | epsilon

<FUNCION>
S -> ( define ( ( TIPO id )  TYPEPARAM ) BLOQUE  )


<LLAMADA> //llamada de funcion
S -> ( id S' )
S' -> EXPRESION S' | LISTFUNCITONS S' | epsilon

<LAMBDA> 
S -> ( ( lambda (PARAM) BLOQUE ) S' )
S' -> EXPRESION S' | LISTFUNCITONS S' | epsilon


( ( lambda ( i1 i2 ) (+ i1 i2) ) 1 2 ) 

( 1 2 ( lambda ( i1 i2) (+ i1 i2) ) )

( lambda (1 2) (i1 i2) (+ i1 i2)  )

-- definicion de funcion
-- guardamos type, nombre, vars, parametros, memory, una variable que se llama como la funcion

-- parametros, memory, puede ser void o regresar algo (este algo tambien puede ser varios returns igual que funcion)
-- memory
-- nombre nos vale un carajo (o podemos tener uno generico(para poder manejar lambda adentro de lambda))
-- 
-- tenemos que crear un scope (del lambda)
-- este scope tiene los parametros
-- cada parametro se tiene que llenar con lo que este en lambda_2
-- no nos interesan los types, solo se va a generar algo
-- 